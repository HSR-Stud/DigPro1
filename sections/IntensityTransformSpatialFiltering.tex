\section{Intensity Transformations and Spatial Filtering \buch{Chapter 3}}

\subsection{Basic intensity transformation functions}
\begin{equation}
s = T(r)
\end{equation}

\begin{itemize}
	\item Image negatives
		\begin{equation}
			s = L-1-r
		\end{equation}
	\item Log transformations
		\begin{equation}
			s = c \cdot \log{(1 + r)}
		\end{equation}
	\item Inverse log transformations
	\item Power-law (Gamma) transformations
		\begin{equation}
			s = c r^\gamma
		\end{equation}
	\item Piecewise-linear transformation functions
	\item Bit-plane slicing
		Split a image in slices for each intensity bit.  All resulting plane are binary images.
		May be used for a simple compression.
	
\end{itemize}


\subsection{Histogram processing}
The histogram shows the number of occurrence of a particular intensity level relative to the total number of pixels (probability of the intensity value)

\subsubsection{Histogram equalization}
The intensity level in an image may be viewed as random variables in the interval $[0, L-1]$.

\paragraph{For continuous Values}
\begin{equation}
	s = T(r) = (L-1)\int_0^r p_r(\omega) d\omega
\end{equation} 

\paragraph{For discrete Values}
\begin{equation}
	s_k = T(r_k) = (L-1) \sum_{j=0}^k p_r(r_j) = \frac{L-1}{MN} \sum_{j=0}^k n_j \qquad k = 0,1,2,\ldots, L-1
\end{equation}
where $MN$ is the total number of pixels, $n_k$ is the number of pixels that have the intensity $r_k$ and $L$ is the number of possible intensity levels in the image.
A plot of $p_r(r_k)$ versus $r_k$ is commonly referred to as a histogram.


\subsubsection{Histogram Matching (Specification)}
If we want to highlight only some intensity levels we need other methods than histogram equalization.

\paragraph{For continuous Values}
\begin{align}
	s	&= T(r) = (L-1) \int_0^r p_r(\omega) d\omega \label{eq:histmatch:cont1} \\
	G(z)&= (L-1) \int_0^z p_z(t) dt \label{eq:histmatch:cont2} \\
	z 	&= G^{-1}[T(r)] = G^{-1}(z) \label{eq:histmatch:cont3}
\end{align}

\begin{enumerate}
  \item Optain $p_r(r)$ from the original image and use Eq.\ref{eq:histmatch:cont1} to obtain the value of $s$.
  \item Use Eq.\ref{eq:histmatch:cont2} to obtain the transformation function $G(z)$
  \item Obtain the inverse transformation $z = G^{-1}(s)$
  \item Obtain the output image by first equalizing the original image using Eq.\ref{eq:histmatch:cont1}; the pixels values in this image are the $s$ values.
  	For each pixel witch value $s$ in the equalized image, perform the inverse mapping $z = G^{-1}(s)$ to obtain the corresponding pixel in the output image. 
\end{enumerate}

\paragraph{For discrete Values}
\begin{align}
	s_k		&= T(r_k) = \frac{L-1}{MN}\sum_{j=0}^{k} n_j \label{eq:histmatch:disc1} \\
	G(z_q)	&= (L-1) \sum_{i=0}^q p_z(z_i) = s_k \label{eq:histmatch:disc2}  \\
	z_q 	&= G^{-1}(s_k)	 
\end{align}

\begin{enumerate}
  \item Compute the histogram $p_r(r)$ of the given image.
  \item Find the histogram equalization transformation (Eq.\ref{eq:histmatch:disc1}), round the resulting $s_k$
  	values to the integer rage $[o, L-1]$
  \item Compute all values of the transformation function $G$ using Eq.\ref{eq:histmatch:disc2}, where $p_z(z_i)$ are the values
  	of the specified histogram. Round the values of $G$ to integers and store them in a table
  \item For every value of $s_k$ use the stored values of $G$ to find the corresponding value of $z_q$ so that $G(z_q)$ is 
  	closest to $s_k$ and store these mappings from $s$ to $z$.
  \item Form the output image by first histogram-equalizing the input image and then mapping every equalized pixel value, $s_k$, of this
  	image to the corresponding value $z_q$ in the output image using the mappings found in step 4.
\end{enumerate}


\subsubsection{Local Histogram Processing}
The techniques described above are easily adapted to local enhancement. The procedure is to define a neighborhood and move its center from pixel to pixel.
At each location, the histogram of the neighborhood is computed and a transformation function is obtained. This function is then used to map the intensity
of the pixel centered in the neighborhood.


\subsubsection{Using Histogram Statistics for Image Enhancement}



\subsection{Fundamentals of spatial filtering\buch{p. 144}}
A spatial filter consist of
\begin{enumerate}
	\item neighborhood (typically a small rectangle)
	\item a predefined operation
\end{enumerate}
If the operation is linear its a \emph{linear spatial filter} otherwise its \emph{nonlinear}.
Linear filters may be described by a correlation or convolution of a filter $w(x,y)$ and the picture $f(x,y)$ 
\begin{eqnarray}
	\text{correlation:}& w(x,y) \text{\FiveStarOpen} f(x,y) = \sum\limits_{s=-a}^{a}\sum\limits_{t=-b}^{b}w(s,t) f(x+s, y+t) \\
	\text{convolution:}& w(x,y) \star f(x,y) = \sum\limits_{s=-a}^{a}\sum\limits_{t=-b}^{b}w(s,t) f(x-s, y-t) 
\end{eqnarray}
Correlation and convolution can be interchanged by rotating the filter by $180^\circ$.
% TODO: add picture
\subsubsection{Smoothing spatial filters}
The output of a smoothing, linear spatial filter is the average of the pixels contained in the neighborhood of the filter mask.
Its main application is blurring and thus reducing noise in images.
\begin{equation}
g(x,y) = \frac{\sum\limits_{s=-a}^{a}\sum\limits_{t=-b}^{b}w(s,t) f(x+s, y+t)}{\sum\limits_{s=-a}^{a}\sum\limits_{t=-b}^{b}w(s,t)}
\end{equation}
\paragraph{box filter}
A filter which all coefficients are equal:
$ \frac{1}{9} \cdot$ \begin{tabular}{|c|c|c|} \hline 1 & 1 & 1 \\ \hline 1 & 1 & 1 \\ \hline 1 & 1 & 1  \\ \hline \end{tabular}
\paragraph{weighted average}
Giving more importance to some pixels:
$ \frac{1}{16} \cdot$ \begin{tabular}{|c|c|c|} \hline 1 & 2 & 1 \\ \hline 2 & 4 & 2 \\ \hline 1 & 2 & 1  \\ \hline \end{tabular}
\subsubsection{Sharpening spatial filters}
This filter highlights transitions in intensity, thus sharpening the image.
It is the opposite of the smoothing filter and since they have a integrative effect it follows that sharpening filters have a derivative effect.
\begin{align}
\frac{\partial f}{\partial x} &= f(x+1) - f(x)& \text{first order derivative} \\
\frac{\partial^2 f}{\partial x^2} &= f(x+1) + f(x-1)  -2 f(x)& \text{second order derivative}
\end{align}

\paragraph{Second Derivative - Laplacian}
The Laplacian is a isotropic (rotation invariant) derivative operator
\begin{align}
\nabla^2f &= \frac{\partial^2 f}{\partial x^2} + \frac{\partial^2 f}{\partial y^2} \\
\nabla^2f &= f(x+1,y) + f(x-1,y) + f(x,y+1) + f(x,y-1) - 4 f(x,y)
\end{align}

\begin{tabular}{|c|c|c|} \hline
0 & 1 & 0  \\ \hline
1 &-4 & 1  \\ \hline
0 & 1 & 0  \\ \hline
\end{tabular}
Implementation with filter masks (rotation invariant for $90^\circ$ rotations)

\begin{tabular}{|c|c|c|} \hline
1 & 1 & 1 \\ \hline
1 &-8 & 1 \\ \hline
1 & 1 & 1 \\ \hline
\end{tabular}
Incorporating the diagonal directions (rotation invariant for $45^\circ$ rotations)
\\ \\
To sharpen an image we add the Laplacian to the original

\begin{equation}
g(x,y) = f(x,y) + c \left[ \nabla^2f(x,y) \right]
\end{equation}

\paragraph{Unsharp Masking / Highboost}
\begin{enumerate}
\item Blur the original $\bar{f}$
\item Subtract the blurred image from the original (gives the mask $g_{mask}$)
\item Add the mask to the original
\end{enumerate}
\begin{align}
g_{mask}(x,y) &= f(x,y) - \bar{f}(x,y) \\
g(x,y) &= f(x,y) + k \cdot g_{mask}(x,y)
\end{align}

with $k=1$ this filter is called unsharp masking, with $k>1$ highboost.

\paragraph{First-Order Derivative - Gradient}
The first derivative in an image is the magnitude of the gradient.
The gradient of image $f$ at $(x,y)$ is a two-dimensional \emph{vector} pointing in the direction of the greatest rate of change.
\begin{equation}
\nabla f \equiv grad(f) \equiv \begin{pmatrix}g_x\\g_y\end{pmatrix} = \begin{pmatrix} \dfrac{\partial f}{\partial x} \\ \\ \dfrac{\partial f}{\partial y} \end{pmatrix}
\end{equation}
The magnitude of the gradient, is the value of the rate of change into the direction of the gradient.
\begin{equation}
M(x,y) = \sqrt{g_x^2 + g_y^2}
\end{equation}
\begin{itemize}
\item isotropic but not linear
\item $M(x,y)$ is called the gradient image
\item a popular approximation is $M(x,y) \approx |g_x| + |g_y|$
\end{itemize}

The gradient can be approximated using filter masks.

\begin{itemize}
	\item Roberts cross gradient operators
		\begin{itemize}
		\item \begin{tabular}{|c|c|} \hline
		-1 & 0 \\ \hline
		 0 & 1 \\ \hline
		\end{tabular}
		\begin{tabular}{|c|c|} \hline
		 0 &-1 \\ \hline
		 1 & 0 \\ \hline
		\end{tabular}
	\item no center of symmetry $\rightarrow$ difficult to implement
	\end{itemize}
		\item  Sobel operators
		\begin{itemize}
		\item \begin{tabular}{|c|c|c|} \hline
		-1 &-2 &-1 \\ \hline
		 0 & 0 & 0 \\ \hline
		 1 & 2 & 1 \\ \hline
		\end{tabular}
		\begin{tabular}{|c|c|c|} \hline
		-1 & 0 & 1 \\ \hline
		-2 & 0 & 2 \\ \hline
		-1 & 0 & 1 \\ \hline
		\end{tabular}
		\item 3x3 neighborhood $\rightarrow$ smoothing
		\end{itemize}
\end{itemize}
