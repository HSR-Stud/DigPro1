\section{Image restoration and reconstruction}
\subsection{Noise models}

\subsection{Restoration in the presence of noise only - spatial filtering}
\subsubsection{Mean Filters}

\textbf{Arithmetic mean filter}\\
This filter is a standard filter.
\begin{equation}
	\hat{f}(x,y)= \frac{1}{m  n} \sum\limits_{(s,t)\in S_{xy}}g(s,t)
\end{equation}

\textbf{Geometric mean filter}\\
Smooth similar to arithmetic mean, but less loss of detail.
\begin{equation}
	\hat{f}(x,y)= \left[\prod\limits_{(s,t)\in S_{xy}} g(s,t)\right]^\frac{1}{mn}
\end{equation}

\textbf{Harmonic mean filter}\\
Works well on slat noise and not work for pepper noise. It does well also with other types of noise like Gaussian noise
\begin{equation}
	\hat{f}(x,y)= \frac{mn}{\sum\limits_{(s,t)\in S_{xy}} \frac{1}{g(s,t)}}
\end{equation}

\textbf{Contraharmonic mean filter}\\
\begin{itemize}
\item For positive Q, good for pepper noise
\item For negative Q, good for salt noise
\item For Q = -1, it is a harmonic mean filter
\item For Q = 0, it is a arithmetic mean filter\\ \\
\textbf{This filter can not simultaneously reduce salt and pepper noise}
\end{itemize}

\begin{equation}
	\hat{f}(x,y)= \frac{\sum\limits_{(s,t)\in S_{xy}} g(s,t)^{Q+1}}{\sum\limits_{(s,t)\in S_{xy}} g(s,t)^Q}
\end{equation}

\subsubsection{Order-Statistic Filters}

The output of these filters depends on the order of the pixel values. \\ \\

\textbf{Median filter}\\
Quite popular, since they result in good noise, without much smoothing \\
\begin{equation}
	\hat{f}(x,y)=\underset{(s,t) \in S_{xy}}{\text{median}}\{g(s,t) \}
\end{equation}

\textbf{Max filter}\\
This filter picks the maximum of the neighborhood, also it reduce the pepper noise.
\begin{equation}
	\hat{f}(x,y)=\underset{(s,t) \in S_{xy}}{\text{max}}\{g(s,t) \}
\end{equation}

\textbf{Min filter}\\
This filter picks the minimum of the neighborhood, also it reduce the salt noise.
\begin{equation}
	\hat{f}(x,y)=\underset{(s,t) \in S_{xy}}{\text{min}}\{g(s,t) \}
\end{equation}

\textbf{Midpoint filter}\\
The midpoint filter simply computes the midpoint between the maximum and the minimum values in the neighborhood. \\
It works best for randomly distributed noise, like Gaussian or uniform noise.
\begin{equation}
	\hat{f}(x,y)=\frac{1}{2} \left[ \underset{(s,t) \in S_{xy}}{\text{max}}\{g(s,t) \} + \underset{(s,t) \in S_{xy}}{\text{min}}\{g(s,t) \}\right]
\end{equation}

\textbf{Alpha-trimmed filter}\\
It is robust against outliers and it is good against "normal" noise.\\ 

Suppose that we delete the $d/2$ lowest and $d/2$ highest intensity values of $g(s,t)$ in the neighborhood $S_{xy}$. Let $g_r{s,t}$ represent the remaining $mn-d$ pixels.
\begin{itemize}
	\item $d$ can range from $mn-1$
	\item When $d=0$, then it is a arithmetic mean filter
	\item When $d=mn-1$, then the filter becomes a median filter
\end{itemize}
\begin{equation}
	\hat{f}(x,y)=\frac{1}{mn-d} \sum\limits_{(s,t)\in S_{xy}} g_r(s,t)
\end{equation}

\subsection{Restoration in the presence of noise only - frequency domain filtering for periodic noise}


\subsection{Estimating the degradation function}


\subsection{Inverse filtering}


\subsection{Constrained leas squares filtering}


\subsection{Geometric mean filter}

